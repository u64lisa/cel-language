
/*
Multiline Comment test
Does it work?
Yes!
*/

// Single line comment test
// Very cool!

constant tapeSize: int = 45;

function tape(statement: String) -> String {
    return " " * round((tapeSize - size(statement)) / 2) + statement + "\n" + "-" * tapeSize;
}

function printTape(statement: String) => println("\n" + tape(statement));


"Statement 1";
2 + 2;

// =====================================================================================================
//                                          BINARY OPERATIONS

printTape("BINARY OPERATIONS");
println(`3 + 5 = ${3 + 5}`);
println(`3 - 5 = ${3 - 5}`);
println(`3 * 5 = ${3 * 5}`);
println(`3 / 5 = ${3 / 5}`);
println(`3 % 5 = ${3 % 5}`);
println(`3 ^ 5 = ${3 ^ 5}`);
println(`"A" + "B" is ${"A" + "B"}`);
println(`[1, 2] + [3, 4] is ${[1, 2] + [3, 4]}`);
println(`null : 5 = ${null : 5}`);

// =====================================================================================================
//                                          UNARY OPERATIONS

printTape("UNARY OPERATIONS");
var x = 5;
println(`x++ = ${x} -> ${x++}`);
println(`x-- = ${x} -> ${x--}`);
println(`++5 = ${++5}`);
println(`--3 = ${--3}`);

// =====================================================================================================
//                                          CONDITIONS

printTape("CONDITIONALS");
println(`true & false => ${true & false}`);
println(`true | false => ${true | false}`);
println(`5 > 3 => ${5 > 3}`);
println(`5 < 3 => ${5 < 3}`);
println(`5 >= 3 => ${5 >= 3}`);
println(`5 <= 3 => ${5 <= 3}`);
println(`A == B => ${"A" == "B"}`);
println(`A == A => ${"A" == "A"}`);
println(`A != B => ${"A" != "B"}`);

// =====================================================================================================
//                                          BITWISE OPERATIONS

printTape("BITWISE OPERATIONS");
println(`3 ~> 2 = ${3 ~> 2}`);
println(`3 <~ 2 = ${3 <~ 2}`);
println(`3 ~~ 5 = ${3 ~~ 5}`);
println(`3 ~& 5 = ${3 ~& 5}`);
println(`3 ~| 5 = ${3 ~| 5}`);
println(`3 ~^ 5 = ${3 ~^ 5}`);

// =====================================================================================================
//                                          HEXADECIMAL

printTape("HEXADECIMAL");
println(`0xABC123 -> ${0 + 0xABC123}`);

// =====================================================================================================
//                                          ALGEBRA

printTape("ALGEBRA");
println(`4x where x -> ${x} = ${4x}`);
destructor x;

// =====================================================================================================
//                                          VARIABLES

printTape("VARIABLES");

function varFail[] yields catcher {
    var x = 3;
    constant y = "Hello";
    x => 4;
    y => "Goodbye!";
}

println(catch(varFail()));

function multipleAssignment {
    var x, y, z;
    x => 1; y => 3.14; z => 3;
}

multipleAssignment();

function callbacks {
    var x = 4;
    cal y -> x ^ 2;

    println(y);

    x => 8;
    println(y);
}

callbacks();

function range[] yields catcher {
    var sbyte[-127 | 127] = 56;
    var usbyte[255] = 12;

    usbyte => -1;
}

println(catch(range()));

// =====================================================================================================
//                                          FORMAT STRING

printTape("FORMAT STRINGS");

var x = 4;
println(`The value of x is ${x}`);
println(`To write ${x} you can do !${x}`);
destructor x;

// =====================================================================================================
//                                          LISTS

printTape("LISTS");

var lst: list = [1, 2];

println( lst[0] );
// Prints the first element of the lst, which is 1 in this case.

lst += [3, 4];
// Extends the lst with the elements 3 and 4.
println( lst );
// Prints [1, 2, 3, 4]

lst /= 3;
// Removes 3 from the lst.
append(lst, 6);

// Adds 6 to the lst.
println(lst);

destructor lst;

// =====================================================================================================
//                                          DICTIONARIES

printTape("DICTIONARIES");

var coolDict: map = ({
    "abc": 123,
    "Hello": "world."
});

set(coolDict, "Hello", "world!");
// Sets the value of the key "Hello" from "world." to "world!".

delete(coolDict, "abc");
// Removes the key value pair "abc": 123 from the dictionary.

println(coolDict);
println("Hello" + " " + coolDict["Hello"]);
// Prints "Hello world!".

destructor coolDict;

// =====================================================================================================
//                                          CONDITIONALS

printTape("CONDITIONALS");
if (true) {
    println("This will always run!");
} elseIf (false) {
    println("This will never run. :(");
} else {
    println("If this ever runs, seek shelter immediately,
             the world is ending.");
}

var input = randomInt(0, 15);

var query = ? input > 10 : "Number is awesome!"
             $ input <  5 : "Number is cool."
             $_           : "Number is meh...";
println(`${input} : ${query}`);

switch (input) {
    case 1: pass;
    case 3: pass;
    case 5: pass;
    case 7: pass;
    case 9:
        println("Odd number!");
        break;
    // Fall through makes it so that all the cases up until case 9 execute this code.

    case 2: pass;
    case 4: pass;
    case 6: pass;
    case 8:
        println("Even number!");
        break;

    default:
        println("Unhandled number...");
    // This will execute if the number is not in any of the above cases.
};

let matched = match (input) {
   case 2 -> 4;
   case 4 -> 8;
   case 8 -> 12;

   default -> 0;
};
println(matched);

destructor matched;
destructor input;

// =====================================================================================================
//                                          LOOPS

printTape("LOOPS");

var index = 0;
var lp = loop => if (index > 5) break;
                    else index++;
println(lp);

var r: float;
loop {
  if ((r => random()) > 0.5)
    break;
  println(r);
}

var lp = for (n -> 0:3) => 2 ^ n;
println(lp);

for (i -> 3:5 >> 0.5) {
    println(i);
    // Prints i for each iteration.
}

var lp = for (n <- [1, 2, 3]) => n + 2;
println(lp);

for (i <- ["Hello", "world!"]) {
    println(i);
    // Prints i for each iteration.
}

var a: float = 1;
var lp = while (a < 10) => a => -(a + abs(a) / a);
println(lp);

while (true) {
    var r = random();
    if (r > 0.5) { break; }
    println(r);
}

do {
  println("This condition is false!");
} while (1 == 2);

destructor a;
destructor lp;
destructor r;
destructor index;

// =====================================================================================================
//                                          FUNCTIONS

printTape("FUNCTIONS");

function addOne(x) => x + 1;
println(addOne(5));

function add(x: float, y: float = 1) -> float {
    return x + y;
}
println(add(3, 4));
println(add(5));

function myGeneric(x: T)<T> => println(`${x} has a generic type of ${type(x)}`);
myGeneric(2)<float>;

function iterativePrint(..messages) {
  // Iterates through each argument and prints it
  for (i <- messages) {
    print(i);
  } println("");
}
iterativePrint("a", "b", "c");

function printNamed(\ map) {
  // Iterates through every pair and prints it
  for (key <- list(map)) {
    println(`${key}: ${map[key]}`);
  }
}
printNamed(\ a: "b", c: 4, hello: "world");

/*
import time;

function async printTen<msg> {
  for (i -> 0:10) {
    println(msg);
    time::halt(500); // Pauses for 500ms.
  }
}

printTen("This is asynchronous!");
printTen("This is also asynchronous!");
time::halt(5000);
println("ok!");

*/


function myCoolDecorator(func<any>: any) yields any<any> {
    function inner(x) {
        println(x);
        var r = func(x);
        println(r);
        return r;
    }
    return inner;
}

/myCoolDecorator/
function myCoolFunc(x) => x + 1;

function offsetDecorator(x) yields (any<any>)<any<any>> {
    function middle(func<any>: any) yields any<any> {
        function inner(y) {
            return func(y) + x;
        }
        return inner;
    }
    return middle;
}

/offsetDecorator(5)/
function myCoolerFunc(x) => x + 1;

// Applies the given decorator

myCoolFunc(5);
println(myCoolerFunc(5));

// =====================================================================================================
//                                          ENUMERATORS

printTape("ENUMERATORS");

enum PizzaToppings {
  sausage,
  pineapple,
  pepperoni,
};

var favorite = PizzaToppings.sausage;
if (favorite == PizzaToppings.pineapple) {
  println("You are mentally unstable.");
} else println(str(favorite) + " is alright.");

enum Message {
    Quit,
    Move { x: float, y: float },
    Write { text: any },
    ChangeColor { r: float, g: float, b: float },
};

let write = Message.Write("mytext");
println(write.text); // Prints "mytext"

// =====================================================================================================
//                                          STRUCTURES

printTape("STRUCTURES");

structure Vector3 {
  x,
  y,
  z
};

// Creates a new struct Vector3 with the attributes
// x, y, and z.

structure Message {
  username,
  contents
};

let msg = Message("John Doe", "Hello world!");
// Creates a new message instance.

println(msg.username + " writes:");
println(msg.contents);
// Gets the contents of the message and
// prints them out.

// =====================================================================================================
//                                          OBJECTS

printTape("OBJECTS");

object Pizza {
      topping, breading;
      // Declares the attributes topping and breading.

      constructor(t, b) {
        attribute topping = t;
        attribute breading = b;

        // Creates a constructor that takes in t and b,
        // then assigns toppings to t and breading to b.
      }

    method details {
      println("I am a pizza with " + this.breading
                + " breading and " + this.topping + ".");
    }

}

let piz = Pizza("sausage", "pretzel");
piz.details();

object MyCoolMethods {
  method public publicMethod {
    println("I am public!");
  }

  method private privateMethod {
    println("I am private! Wait, how did you call me??");
  }

  method static staticMethod {
    println("You can call me anywhere!");
  }
}

var instance: MyCoolMethods = MyCoolMethods();
instance.publicMethod();
MyCoolMethods.staticMethod();

object Parent {
  inheritedAttribute;

  constructor(x) {
    attribute inheritedAttribute = x;
  }

  method inheritedFunction(y) => this.inheritedAttribute + y;

}

object Child -> Parent {
  constructor(x) {
    attribute inheritedAttribute = x + 2;
    // Overrides the default constructor and replaces it with this one, which adds 2 to x before assigning it to v.
  }
}

println(Parent(5).inheritedFunction(2));
// Prints 7.

println(Child(5).inheritedFunction(2));
// Prints 9, since 2 is added to x in the overridden constructor.

// =====================================================================================================
//                                          HEADERS

printTape("HEADERS");

function fib(x) {
    #optimize;
    if (x <= 2) return x;
    return fib(x - 1) + fib(x - 2);
}
println(fib(76));

// =====================================================================================================
//                                          MATRICES

printTape("MATRICES TYPE");

constant SPACING: int = 3;
class Matrix {
    rows: float = -1;
    vector: list = [];
    cols: float = -1;

    constructor(..args) {
        vector => args;
        rows   => size(vector);
        assert rows > 0;
        cols   => size(vector[0]);
    }

    method bin string {
        let colPad = for (_ -> 0:cols) => 0;
        for (row <- vector) {
            for (i -> 0:cols) {
                setIndex(colPad, |int| max(size(str(row[i])), |float| colPad[i]), |int| i);
            }
        }

        let totalPad = 0;
        for (item <- colPad) { totalPad += |int| item; }

        var st: String = "/ " + " " * totalPad + " " * (|int| --cols) * SPACING + " \\\n";
        for (r -> 0:rows) {
            let row = vector[r];
            st += "| ";
            for (i -> 0:cols) {
                let col = row[i];
                st += " " * (|int| colPad[i] - size(str(col))) + str(col) + " " * SPACING;
            } st => substr(|String| st, |int| 0, |int| size(st) - SPACING) + " |\n";
        } st += "\\ " + " " * totalPad + " " * (|int| --cols) * SPACING + " /";
        return st;
    }

    method copy {
        let s = for ( row <- vector ) => for ( col <- row ) => col;
        Matrix(..s)
    }

    method bin add(other: Matrix) yields Matrix {
        assert type(other) == "Matrix";

        assert cols == other.cols;
        assert rows == other.rows;

        let s = for ( r -> 0:rows ) => for ( c -> 0:cols ) => vector[r][c] + other.vector[r][c];
        return Matrix(..s);
    }

    method bin sub(other: Matrix) yields Matrix {
        return this.add(other * -1);
    }

    method det(vector: list = []) yields float {
        if (vector == []) vector => this.vector;
        assert size(vector) > 0;
        assert size(vector) == size(vector[0]);

        if (size(vector) == 2)
            return |float| (vector[0][0] * vector[1][1] - vector[0][1] * vector[1][0]);

        var d: float = 0;
        for (i -> 0:size(vector)) {
            let copy = for (row <- sublist(vector, 1, size(vector))) => for (col <- row) => col;
            for (row <- copy) {
                pop(|list| row, |int| i);
            }
            d += ((-1) ^ i) * (|float| vector[0][i]) * det(copy);
        }
        return d;
    }

    method bin mul(o: any) yields Matrix {
        if (type(o) == "float" | type(o) == "int") {
            let s = for ( row <- vector ) => for ( yoinkers <- row ) => |float| (yoinkers * o);
            return Matrix(..s);
        }

        var other: Matrix = |Matrix| o;
        println(type(other));
        assert type(other) == "Matrix";
        assert cols == other.rows;

        let newVector = [];
        for (r -> 0:rows) {
            append(newVector, []);
            for (c -> 0:other.cols) {
                var x: float = 0;
                for (k -> 0:cols) {
                    x += |float| vector[r][k] * other.vector[k][c];
                }
                append(|list| newVector[r], x);
            }
        }
        return Matrix(..newVector);
    }

}

let A = Matrix([1, 2, 3], [4, 5, 6]);
let B = Matrix([7, 8, 9], [1, 2, 3]);
let C = Matrix([7, 8], [1, 12], [3, -12]);

println("A: \n" + str(A) + "\n");
println("B: \n" + str(B) + "\n");
println("C: \n" + str(C) + "\n");
println("A + B: \n" + str(A + B) + "\n");
println("A - B: \n" + str(A - B) + "\n");
println("C * A: \n" + str(C * A) + "\n");
println("The determinant of C * A: " + str((C * A).det()) + "\n");
